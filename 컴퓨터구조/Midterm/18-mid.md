‘18 가을학기 컴퓨터구조(스마트시스템SW 2) 중간고사

------------------------------------------------

## 1. (하나당 2.5점) (20점) 각 질문에 대하여 간단히 설명하시오

(1) Instruction Set Architecture ?
```
하드웨어와 저수준 소프트웨어 사이의 추상화된 인터페이스를 의미함. 구체적으로 얘기하면, 컴퓨터에서 사용될 명령어 set (레지스터, 메모리 access, IO 포함)을 먼저 정의(instruction set architecture)함으로써 컴퓨터 구조를 설계하는 방법임.
```
(2) 32 bit CPU와 64 bit CPU의 차이점은 무엇인가 ? CPU안에서 무엇을 보면 32 bit인지 64 bit인지를 알 수 있나 ?
```
컴퓨터에서 한 번 연산할 때 최대 32 비트 단위로 처리하느냐 64 비트 단위로 처리하느냐에 따라 다르다. CPU내 레지스터 비트수(data 크기) 또는 data bus bandwidth를 보면 알 수 있다.
```
(3) complier와 assembler 차이점 ?
```
compiler는 고급언어(high level language)를 어셈블리언어 또는 기계언어로 변환해주는 소프트웨어이고 assembler는 어셈블리언어를 기계언어로 변환해주는 소프트웨어임 
```
(4) assembly code 와 machine code 차이점 ?
```
machine code는 2 진수로 표현한 명령어이고 assembly code는 machine code를 symbolic 하게 표현한 것이다.  
```
(5) ARM CPU에서 특권(privileged) 모드와 비특권모드 차이점 ?
```
특권모드에서는 CPU가 제공하는 모든 명령어 사용이 가능하나 비특권모드에서는 일부 명령어 사용이 제한된다.
```
(6) 2GHz 클럭을 사용하는 CPU A에서 10초 걸리는 작업을 CPU B에서는 CPU A에서 사용하는 클럭 cycles 수의 1.2 배 사용하면서 수행시간은 6초로 단축하고자 한다. CPU B에서 사용해야 하는 clock rate ?
```
CPU cycle time A = CPU time A * CPU clock rate A = 10 * 2*(10**9) = 20 *  (10**9)

CPU clock rate B = CPU cycle time B / CPU time B = 1.2 * CPU cycle time A / CPU time B = 1.2 * 20 * (10**9) /6 = 4 * (10**9) = 4 Ghz
```
(7) 5단계 명령어 pipeline에서 각 단계에서 수행되는 동작을 설명하시오.
``` 
명령어 갖고 오기 
명령어 해독하는 동안 레지스터 읽기
연산동작을 수행하거나 주소를 계산하기
데이터 메모리의 operand 접근하여 읽거나 쓰기
결과값을 레지스터에 쓰기
```
(8) k개의 stage를 가진 명령어 pipeline에서 clock cycle time=t, n개의 명령어를 실행한다 하자. pipeline사용한 경우가 pipeline을 사용하지 않은 경우 대비 speed up 효과를 n, k, t를 사용해 표현하시오. 만일 n이 아주 커지면 speed up 효과값은 얼마인가 ? 
```
SpeedUp = nkt / (k-1)t + nt = nkt / (k+n-1)t
lim(n->oo) nkt / (k+n-1)t = k

만일 n이 아주 커지면  speedup = k 가 된다.
```
## 2. (10점) 다음은 ARM 명령어들에 대한 질문이다.

(1) (3점) R1=0x86000000, R0=0x68000000, 상태 bit들 N=0, Z=0, C=1, V=0 라고 하자. ADDS R2, R1, R0 명령어와 CMP R1, R0 명령어를 각각 수행후 결과를 설명하시오 (CMP 명령어 수행시 2의 보수를 취해 더하는 방식으로 처리한다고 가정함). 결과값이 R2에 저장되었다면 그 결과값을 16진수로 표기하시오. 또한 상태 bit N, Z, C, V 값이 수정되었다면 그 값을 쓰시오.
```
ADDS: R2=0xEE000000, N=1, Z=0, C=0, V=0
CMP:   N=0, Z=0, C=1, V=1
```
(2) (3점) LDR R8, [R3, #4]!와 LDR R8, [R3], #4 의 차이점을 설명하시오. 수행후 R3값은 동일한가 아니면 다른가 ? 
```
R3+4 의 번지 값을 읽어 R8로 복사, R3는 R3+4로 update
R3의 번지값을 읽어 R8로 복사, R3는 R3+4로 update

수행후 R3는 동일
```
(3) (4점) 아래의 C 코드를 컴파일했다고 하자.
```c
 while (save[i]==k) i+=1;
 ```
변수 i는 R0, k는 R1, save 배열시작주소는 R2에 할당되었다고 하자. 아래의 complied ARM code에서 ?? 를 채우시오. 
```
Loop    LDR   R3, [R2, R0, LSL #2]
        CMP   R3, R1      
        ADDEQ R0, R0, #1
        BEQ   Loop   
Exit
```
## 3. (20점) 다음은 bubblesort에 관한 질문이다.
(1) (8점) 그림 1은 C로 작성된 bubblesort 코드 및 ARM 32 bit 어셈블리코드로 변환된 코드를 보여준다. 26번줄부터 30번줄까지 ??? 로 된 부분을 어셈블리코드로 완성하세요. 그 부분은 C 코드상에서 보면 inner loop에 해당된다. 
```
ADD R12, R0, R3, LSL #2
LDR R4, [R12, #0]
LDR R5, [R12, #4]
CMP R4, R5
BLE EXIT2
```
(2) (4점) 7번줄부터 12번줄 코드, 46번줄부터 51번줄을 각각 multiple store, load 명령어로 대체하시오.
```
STMDB SP! {R2, R3, R6, R7, LR}
LDMIA SP! {R2, R3, R6, R7, LR}
```
(3) (8점) 32번줄, 36번줄에 보면 multiple store, load 명령어가 있다. 32번줄 명령어가 시작되기전 SP=1000 (십진수), R0=0, R1=1, R2=2, R3=3, R12=12 (십진수)가 들어 있다고 하자. 32번줄 수행후 변화 내용을 설명하시오. 스텍(메모리) 번지 및 내용을 쓰시오. 수행후 SP 값은 ? 36번줄 명령어가 시작되기전 R0=1, R1=2, R2=3, R3=4, R12=13 (십진수)가 들어 있다고 하자. 36번줄 수행후 변화 내용을 설명하시오. 각 레지스터 값이 메모리 어느 번지에서 왔는지 설명하시오. 수행후 SP 값은 ?
```
32번지 수행후 SP=980
996 번지 – 12
992 번지 – 3
988 번지 – 2
984 번지 – 1
980 번지 – 0

36번지 수행후 SP=1000
R0=0, R1=1, R2=2, R3=3, R12=12
```
## 4. (15점) 특정 메모리 영역에서 패턴 검색

(1) (12점) 그림 2는 특정 메모리 영역에서 출현 빈도수가 가장 높은 byte 패턴을 찾는(Top1 찾기) 어셈블리코드입니다. 0x00 ~ 0xff까지의 패턴을 이용하여 순차적으로 검사합니다.  패턴이 0x00 일 경우 그 메모리 구간에 들어 있는 총 횟수를 계산하여 R7에는 패턴의 횟수, R8에는 패턴을 저장합니다 (현재로는 이 패턴이 Top1 이고 패턴 출현횟수가 Top1의 갯수임). 패턴 값을 0x01로 증가하여 같은 과정을 반복합니다. 만일 0X01의 총 개수가  저장된 Top1의 개수보다 크면 Top1 패턴, Top1의 개수를 update합니다. 이 과정을 패턴이 0xff 될 때까지 반복합니다. main으로 return하기 전에 어셈블리코드에서 Top1 패턴, Top1 패턴 횟수를 result[0], result[1]에 저장합니다. 그림 2 어셈블리 코드를 Top1 및 Top2 (출현 빈도수가 2번째 높은 패턴)를 찾는 어셈블리 프로그램으로 확장하시오. main으로 return하기 바로 전에 Top1의 패턴 횟수, Top1의 패턴, Top2의 패턴 횟수, Top2의 패턴을 result[0], result[1], result[2], result[3]에 저장하는 것으로 합니다. main에서 result[2]는 result[4]로 수정되고 출력하는 코드는 위 결과를 출력하게 이미 수정되었다고 가정합니다.  *** 코드 확장시 코드를 최적화하시오. *** 
```
11번줄 뒤에 추가
(2점) MOVR10, #0
MOV R11, #0 

23번줄부터 CMPR3, R7
(4점)MOVGTR10, R7; Top1 보다 클 때
MOVGTR11, R8
MOVGTR7, R3
MOVGTR8, R4
(4점)BGTLOOP3; Top1 보다는 작고 Top2 보다는 클 때
CMPR3, R10
MOVGTR10, R3
MOVGTR11, R4

LOOP3CMP R4, #0xff

31번줄 뒤에
(2점)STRR11, [R6, #8]
STRR10, [R6, #12]
```
(2) (3점) 그림 2 코드를 특정 메모리 영역에서 출현 빈도수가 가장 작은 byte 패턴을 찾는 프로그램으로 수정하려고 한다. 수정내용을 쓰시오.
```
24번줄 MOVLTR7, R3
25번줄 MOVLTR8, R4
```
## 5. (35점) 그림 3은 single clock으로 수행되는 MIPS CPU 설계 블록도이고(하나의 CPU clock을 이용하여 하나의 명령어를 수행). 그림 4는 일부 MIPS 명령어에 대한 명령어 포맷이다. 

(1) (3점) CPU는 크게 3가지 모듈로 구성된다. 모듈이름을 나열하시오.  

    ALU, Registers, Control Unit

(2) (3점) 그림 3에서 Control Unit에 속하는 component 이름을 열거하시오 (예: C1). 

    C4, C8

아래 (3) ~ (5)는 다음 페이지에서 간단한 설명

(3) (8점) MIPS 명령어 ADD $1, $2, $3를 수행한다고 하자 ($1, $2, $3는 레지스터 R1, R2, R3를 의미함. MIPS에는 레지스터가 총 32개 있음. 위 명령어는 ARM 명령어 ADD R1, R2, R3에 해당). 

    ① 이 명령어 수행을 위해 그림 3에서 사용되는 component 이름을 모두 열거하고 각 component에서 담당하는 기능을 설명하시오. 

    ② 그림 3 맨 오른쪽 표에서 (ALUOp는 제외) 각 control signal값들을 쓰시오(0, 1, 또는 x). 그렇게 나온 이유를 각각 설명하시오. 

(4) (8점) MIPS 명령어 beq $1, $2, 7 를 수행한다고 하자 (ARM 명령어 CMP R1, R2와 BEQ 7이 하나로 결합된 형태). 

    ① 이 명령어 수행을 위해 사용되는 component를 모두 열거하고 각 component에서 담당하는 기능을 설명하시오.

    ② 그림 3 맨 오른쪽 표에서 (ALUOp는 제외) 각 control signal값들을 쓰시오(0, 1, 또는 x). 그렇게 나온 이유를 각각 설명하시오.

(5) (8점) MIPS 명령어 lw $1, 4($2) 를 수행한다고 하자 (ARM 명령어 LDR R1, [R2, #4]에 해당). 

    ① 이 명령어 수행을 위해 사용되는 component를 모두 열거하고 각 component에서 담당하는 기능을 설명하시오.

    ② 그림 3 맨 오른쪽 표에서 (ALUOp는 제외) 각 control signal값들을 쓰시오(0, 1, 또는 x). 그렇게 나온 이유를 각각 설명하시오.

(6) (5점) 그림 3을 pipelined 방식(multi cycle)로 구현을 변경한다면 변경내용이 무엇인가 ? 그것의 용도 및 필요한 이유를 설명하시오.
```
pipeline register 4개
IF/ID, ID/EX, EX/MEM, MEM/WB
이전 단계의 연산결과를 임시저장, CU의 제어신호저장, 명령어 내용 일부 저장
각 단계에서 수행되는 각 명령어가 독립적으로 수행되게 해준다
```
‘20 가을학기 컴퓨터구조(스마트SW 2) 중간고사
------------------------------------------------

## 1. (하나당 2.5점) (20점) 각 질문에 대하여 간단히 설명하시오

(1) Instruction Set Architecture ?
```
    하드웨어와 저수준 소프트웨어 사이의 추상화된 인터페이스를 의미함. 구체적으로 얘기하면, 컴퓨터에서 사용될 명령어 set (레지스터, 메모리 access, IO 포함)을 먼저 정의(instruction set architecture)함으로써 컴퓨터 구조를 설계하는 방법임.
```
(2) 32 bit CPU와 64 bit CPU의 차이점은 무엇인가? CPU안에서 무엇을 보면 32 bit인지 64 bit인지를 알 수 있나?
```
    컴퓨터에서 한 번 연산할 때 최대 32 비트 단위로 처리하느냐 64 비트 단위로 처리하느냐에 따라 다르다. CPU내 레지스터 비트수(data 크기) 또는 data bus bandwidth를 보면 알 수 있다.
```
(3) CISC와 RISC의 차이점 ?
```
    CISC는 가능한한 많은 종류의 명령어를 하드웨어로 구현하며 다양한 명령어 format를 지원함. 코드 밀집도가 높다. RISC는 자주 사용하는 명령어 위주로 단순한 형태로 구현하며 나머지 명령어는 소프트웨어로 구현함. 코드 밀집도가 낮다.
```
(4) ARM CPU에서 program status register ?
```
    CPU 내의 현재 수행 상태들을 저장하는 레지스터임. 보통 N, Z, C, V등의 condition bit들과 I, F, T와 같은 control bit들이 있다
```
(5) 2개의 CPU A, B가 같은 instruction set architecture 사용하고, 같은 program을 수행한다고 하자.  Instruction Counter(A)= 50, Clock cycle time(A) = 250ps, CPI(A) = 2.0, Instruction Counter( B)= 50, Clock cycle time(B) = 500ps, CPI(B) = 1.5 일 때 어느 CPU가 얼만큼 더 빠른가 ? 
```
    A의 수행시간 = 50 x 2.0 x 250ps 
    B의 수행시간 = 50 x 1.5 x 500ps

    성능A/성능B = B의 수행시간 /A의 수행시간 = (50 x 1.5 x 500)/(IC x 2.0 x 250) = 1.5, A가 B보다 1.5배 빠르다
```
(6)  조합회로와 순차회로의 차이점은 ?  아래 소자들중 순차회로에 속하는 소자를 답하시오. adder, multiplexer, decoder,  register, ALU,  memory
```
(1.5점) 조합회로에는 기억소자가 없는데 순차회로에는 기억소자가 있다. 
(하나당 0.5점) register, memory
```
(7) k개의 stage를 가진 명령어 pipeline에서 clock cycle time=t, n개의 명령어를 실행한다 하자. pipeline사용한 경우가 pipeline을 사용하지 않은 경우 대비 speed up 효과를 n, k, t를 사용해 표현하시오. 만일 n이 아주 커지면 speed up 효과값은 얼마인가 ? 
```

SpeedUp = nkt / (k-1)t + nt = nkt / kt + (n-1)t 
lim n=>% SpeedUp = k

만일 n이 아주 커지면  speedup = k 가 된다.
```
(8) 컴퓨터의 성능을 표현하는 용어들이다. execution time (=response time) 정의는 ?  throughput의 정의는 ? pipelining은 instruction execution time 과 instruction throughput 중 1) 둘다 향상시킨다 2) execution time은 향상시키지 못하고 throughput은 향상시킨다 3) execution time은 향상시키고 throughput은 향상시키지 못한다. 4) 둘다 향상시키지 못한다. 1) ~4) 중 맞는 것은 ? 
```
(0.5점) execution time: 수행시작하여 종료할 때까지 소요되는 시간
(0.5점) throughput: 단위시간당 처리량
(1.5점) 2) execution time은 향상시키지 못하고 throughput은 향상시킨다
```
## 2. (15점) 다음은 32비트 ARM 명령어에 관한 것이다. 

(1) (6점) R0=0x89000000, R1=0x98000000, 상태 bit들 N=0, Z=0, C=1, V=0 라고 하자. ADDS R2, R0, R1 명령어와 CMP R0, R1 명령어를 각각 수행후 결과를 설명하시오 (CMP 명령어 수행시 2의 보수를 취해 더하는 방식으로 처리한다고 가정함). 결과값이 R2에 저장되었다면 그 결과값을 16진수로 표기하시오. 또한 상태 bit N, Z, C, V 값이 수정되었다면 그 값을 쓰시오.
```
(3점) ADDS R2, R0, R1 명령어(세부항목 하나 틀리면 –1 감점)

    R2=0x21000000
    N=0, Z=0, C=1, V=1 (V값 변화)

(3점) CMP R0, R1 명령어(세부항목 하나 틀리면 –1 감점)

    N=1, Z=0, C=0, V=0 (N, C값 변화)
```
(2) (4.5점) 초기조건 R0=0x04030201, R4=100, M[100]=0x07, M[101]=0x06, M[102]=0x05, M[103]=0x04, M[104]=0x03, M[105]=0x02, M[106]=0x01, M[107]=0x00 이라고 하자. 또한  data는 little endian으로 저장된다고 하자. 아래 각 명령어를 각각 수행한 후, R0, R4, 메모리 내용에 변화가 있다면 그 변화값을 구체적으로 쓰시오 (예: M[100]=0x06) 
```
1) STR R0, [R4, #4] (세부항목 하나 틀리면 –0.5 감점)

    M[104]=0x01, M[105]=0x02, M[106]=0x03, M[107]=0x04

2) STR R0, [R4, #4]! (세부항목 하나 틀리면 –0.5 감점)

    M[104]=0x01, M[105]=0x02, M[106]=0x03, M[107]=0x04, R4=104

3) STR R0, [R4], #4 (세부항목 하나 틀리면 –0.5 감점)

    M[100]=0x01, M[101]=0x02, M[102]=0x03, M[103]=0x04, R4=104

어떤 어셈블리 함수 f2 코드가 다음과 같다고 합시다.

f2: 
    STMFD R13!, {LR}
    .
    BL f3
    .
    LDMFD R13!, {PC}
```
(3)(1.5점) 명령어 BL f3를 수행한다고 하자(이 명령어는 1000번지에 있고, f3 함수 시작주소는 3000번지). 이 명령어 수행으로 레지스터값이 바뀌는 레지스터 이름과 값을 쓰시오.
```
    LR=1004, PC=3000
```
(4)(1.5점) STMFD R13!, {LR} 및 LDMFD R13!, {PC}이 필요한 이유를 설명하시오 (만일 그게 없다면 어떤 문제가 발생하는지를 설명하시오)
```
    BL f3 이전의 LR값이 깨진다. f2 call한 코드로 돌아갈 수 없다
```
(5)(1.5점) STMFD R13!, {LR} 및 LDMFD R13!, {PC} 대신에 STMFD R13!, {R4-R6, LR} 및 LDMFD R13!, {R4-R6, PC} 사용되었다면 어떤 상황에서 이 방법을 사용하는지를 설명하시오.
```
f2 함수내에서 R4-R6를 사용하려고 한다. ( BL f3 코드가 있는 것과 무관 )
```
## 3. (15점) 다음은 ARM 코딩에 관한 것이다.

(1) (3점)  &= ~ (1<<3)를 ARM 어셈블리 코드로 표현하시오. x는  R0에 있다고 가정한다.
```
BIC R0, R0, 1<<3
```
(2) (6점) 아래는 주어진 숫자의 절대값을 계산하는 함수이다. 숫자는 R0를 통해서 이 함수에 전달되고 이 함수의 return값은 R0를 통해 전달된다고 하자. 아래 ?? 어셈블리 코드를 작성하시오.
```
AbsValue:
EOR R1, R0, R0, ASR 31
ADD R0, R1, R0, LSR 31
BXLR
```
(3) (6점) 어떤 C 코드를 컴파일한 결과가 다음과 같다. 
```
Loop    LDR   R3, [R2, R0, LSL #2]
        CMP   R3, R1      
        ADDEQ R0, R0, #1
        BEQ   Loop   
```
```c
 while (array[i]==k) i+=1 // (4점)
```
변수 i는 R0, 변수 k는 R1, array 배열시작주소는 R2에 할당되었다고 하자. C 코드를 쓰시오. 또한, LDR   R3, [R2, R0, LSL #2]에서 LSL #2 동작의 의미를 설명하시오.
```
(2점) index값을 byte 주소값으로 변환하기 위해 4를 곱한다
```
## 4. (10점) r0, r1 두 숫자를 비교한 후 r0가 작을 경우 branch하는 코드를 작성하려고 한다. 숫자가 unsigned 인가 signed인가에 따라 표2의 BLO(unsignd LOwer) 또는 BLT(signed Less Than) 명령어를 사용한다. 사용하는 명령어가 다르다. 32비트 CPU에서는 32 비트 데이터를 사용하나 여기서는 단순하게 하기 위해 4비트 CPU 및 4비트 데이터(b3b2b1b0)를 사용한다고 하자. 만일 signed 숫자라면 최상위 비트(b3)가 sign 비트가 된다.

(1) (5점) unsigned 숫자 2와 11 (십진수)를 각각 4비트 이진수로 표기하시오. 2와 11이 각각 r0, r1 (4비트짜리 레지스터)에 있다고 가정하고 CMP r0, r1를 수행후 (4 비트 연산) N, Z, C, V 상태비트 값을 계산하시오. BLO에서 LO조건이 참인지 거짓인지 CPU는 무엇을 보고  판단하는지를 표 1 및 지금 계산한 상태비트 값들을 갖고 설명하시오.
```
2 = 0010, 11 = 1011
CMP 수행후 0010 + 0101 = 0111
N=0, Z=0, C=0, V=0

LO 조건에서는 C=0 이면 A < B 임. 여기서는 C=0이므로 조건이 참
```
(2) (5점) signed 숫자 2와 -5를 각각 4비트 이진수로 표기하시오. 2와 –5가  각각 r0, r1 (4비트짜리 레지스터)에 있다고 가정하고 CMP r0, r1를 수행후 (4비트 연산) N, Z, C, V 상태비트 값을 계산하시오. BLT에서 LT조건이 참인지 거짓인지 CPU는 무엇을 보고 판단하는지를 표 1 및 지금 계산한 상태비트 값들을 갖고 설명하시오.
```
2 = 0010, -5 = 1011
CMP 수행후 0010 + 0101 = 0111
N=0, Z=0, C=0, V=0

LT 조건에서는 N EXOR V = 1이면 A < B임. 여기서는 N EXOR V = 0 이므로 조건이 거짓임
```
## 5. (15점) 그림 1과 2는 factorial을 recursive 방식으로  계산하는 코드이다. 그림 2 코드에서 5번줄에 현재 멈추어 있다고 하자. 다른 breakpoint들은 삭제하고 8번줄에만 breakpoint가 설정되어 있다고 가정하자.

(1) (3점) Continue를 입력하여 맨 처음 breakpoint 8번줄에 멈추었을 때 6번줄, 7번줄 수행한 결과가 ①,②에 저장되어 있다. ①,② 값들을 화면에 나오는 순서로 16진수로 표기하시오 (①에서 최하위바이트가 먼저 나옴. 0XF6FFF014, 0XF6FFF015 ~ 순서임)
```
①: 40 06 01 00
②: 06 00 00 00
```
(2) (2점) continue를 계속 입력함에 따라 stack ③ ~ ⑭에 저장된다, ③,⑤,....에 저장된 주소는 그림 2에서 어느 코드의 주소에 해당하는가? 코드앞의 줄번호를 쓰시오.

    16번

(3) (4점) 현재 위치는 8번줄에 멈추어 있고, stack에는 ⑭까지 저장되어 있다. SI(single step)을 5번 수행하다고 하자. 수행되는 코드 줄번호, 각 줄 코드 수행후 레지스터 값이 변화하는 경우 레지스터 이름 및 값을 쓰시오.
```
8 N=1, Z=0, C=0, V=0
9
10 R0=1
11 SP =0xf6ffefe8
12 PC = 0x000105f8
```
(4) (6점) 8번줄 breakpoint 삭제하고 21번줄에 breakpoint를 추가했다고 하자. continue를 입력했다고 하자. 21번줄에 멈추었을 때 (몇번째 멈추었는지 순서를 쓰고) r0 및 sp 값을 쓰시오. main 함수로 되돌아갈 때까지 continue를 계속 입력하여 멈출 때마다 위 과정을 반복한다. 
```
1: R0=1, SP=0xf6ffeff0
2: R0=2, SP=0xf6ffeff8
3: R0=6, SP=0xf6fff000
4: R0=24, SP=0xf6fff008
5: R0=120, SP=0xf6fff010
6: R0=720, SP=0xf6fff018
```
## 6. (25점) 그림 3은 single cycle로 명령어를 수행하는 MIPS CPU 설계 블록도이다. 그림 4는 MIPS 명령어 포맷을 나타낸다.
(1) (4점) 그림 3에서 Control Unit에 속하는 component 이름을 열거하시오 (예: C1). 

    C4, C8

(2) (5점) Control Unit 기능을 3줄 이내로 설명하시오.
```
명령어 opcode를 해독하여 명령어 type을 알아낸뒤, 현재 명령어를 수행할 수 있도록 각 control point에 전달할 control signal 생성
```
(3) (6점) MIPS 명령어 ADD $1, $2, $3를 수행한다고 하자 (ARM 명령어 ADD R1, R2, R3에 해당). 이 명령어 수행 도중 그림 3의 Multiplexer (M1, M2, M3, M4)에서 각 입력중 어느 게 선택되었는지 쓰고 (0 또는 1) 그 이유를 설명하시오 (예: M1:0~)
```
M1: 1, [15-11]로 받은 $1 레지스터가 wrire register로 연결되어 연산결과 값을 받아야 한다
M2: 0, Read data 2를 ALU 아래쪽 입력으로 전달하기 위함
M3: 0, ADD 연산후 PC = PC +4를 하기 위함
M4: 0, ALU 연산 결과를 write data로 보내기 위함
```
(4) (10점) MIPS 명령어 beq $1, $2, 7 를 수행한다고 하자 (ARM 명령어 CMP R1, R2와 BEQ 7이 하나로 결합된 형태). 
```
① (5점) 이 명령어 수행을 위해 사용되는 component를 모두 열거하고 각 component에서 담당하는 기능을 설명하시오. (세부항목 하나 틀리면 –1 감점)
② (5점) 그림 3 맨 오른쪽 표에서 (ALUOp는 제외) 각 control signal값들을 쓰시오(0, 1, 또는 x). 그렇게 나온 이유를 각각 설명하시오. (세부항목 하나 틀리면 –1 감점)
```
# [HW3] ARM 명령어(20160402)

다음은 2장에 배운 ARM 명령어이다. 각 명령어의 사용법을 이해하기 위해 아래 표 세 번째 컬럼(예)에 있는 명령어가 각각 수행되었을 때 수행결과를 확인한다.

### 1 산술 명령어 그룹에 대한 부분이다. 초기 값이 r2=0x76543210 (16진수), r3=0x98765432, 상태 bit들 N=0, Z=0, C=1, V=0 라고 하자. 산술명령어 ADDS r1, r2, r3 수행된후 r1 값을 16진수로 표기하시오. 또한 상태 bit N, Z, C, V 값이 수정되었다면 그 값을 쓰시오. ADDS 대신 SUBS가 수행된 후(초기 조건은 위와 동일) r1 값 및 상태비트 값들을 쓰시오. SUB 명령어는 A – B = A + (B의 2의 보수) 방식으로 계산한다고 하자. 
```
CPU에는 Instruction 결과의 상태를 알려주는 상태 레지스터가 있다. 상태 레지스터에는 대표적으로 아래의 flag bit들이 모여 있다.
	N (Negative) : 연산 결과가 음수인 경우 참
	Z (Zero) : 연산 결과가 0인 경우 참
	V (Overflow) : 연산 결과가 표현될 수 있는 비트 범위를 넘긴 경우 참
	C (Carry) : 연산 결과가 최상위 비트(MSB)에서 그 위의 비트로 비트 범위를 넘어서 자리올림이 발생하는 경우 참
ADDS r1, r2, r3
r2      = 0x76 54 32 10 = 0111 0110 0101 0100 0011 0010 0001 0000
r3      = 0x98 76 54 32 = 1001 1000 0111 0110 0101 0100 0011 0010
r1      = 0x0e ca 86 42 = 0000 1110 1100 1010 1000 0110 0100 0010

최상위 비트에 자리올림이 발생했기 때문에 carry 상태가 업데이트 된다.

N = 0, Z = 0, C = 1, V = 0
SUBS r1, r2, r3

r2      = 0x76 54 32 10 = 0111 0110 0101 0100 0011 0010 0001 0000
r3      = 0x98 76 54 32 = 1001 1000 0111 0110 0101 0100 0011 0010
-r3(2의 보수) = 0x67 89 ab ce = 0110 0111 1000 1001 1010 1011 1100 1110

r1      = 0xdd dd dd de = 1101 1101 1101 1101 1101 1101 1101 1110

최상위 비트 borrow가 발생했기 때문에
N = 1, Z = 0, C = 0, V = 1
```
```
Answer)
	ADDS r1, r2, r3  r1 = 0x0e ca 86 42	N = 0, Z = 0, C = 1, V = 0
	SUBS r1, r2, r3	 r1 = 0xdd dd dd de	N = 1, Z = 0, C = 0, V = 1
```
### 2) 데이터 전송 명령어 그룹에 대한 부분이다. 초기값은 r1=1000 (10진수), r2=2000(10진수), 메모리 [2000(10진수)]에는 00, [2001]에는 01, [2002]에는 02,... [2020]에는 20 (10진수)이 저장되어 있다고 가정한다. 위 표에서 LDR r1, [r2, #20] 명령어부터 MOV r1, r2 까지 각각 독립적으로 수행(각 명령어 입장에서 초기 조건은 동일)한다고 하고 수행후 레지스터 및 메모리 내용 변경내용을 각각 설명하시오. CPU는 Little Endian 32bit 방식으로 데이터를 저장한다고 가정한다.
```
Answer) r1 = 1000(10진수) ,0x000003E8(16진수) , r2 = 2000, [2000] -> 00, [2001] -> 01 ... [2020] -> 20 (0x14)
```
```
LDR r1,[r2, #20]
	=> 레지스터 r1 에 r2 에서 20을 더한 값인 메모리[2020]부터의 값을 저장
	[2020] 0x14 [2021] 0x15 [2022] 0x16 [2023] 0x17
	1. LDR r1,[r2, #20]=> r1 = 0x17161514
STR r1,[r2, #20]
	=> 레지스터 r1의 값인 1000을 r2 값에 20을 더한 [2020] 부터 저장함.
	[r1] 1000 => 0x000003E8
	2. STR r1,[r2, #20] => [2020] 0xE8 [2021] 0x03 [2022] 0x00 [2023] 0x00
LDRH r1,[r2, #20] [Half Word]
	[2020] 0x14 [2021] 0x15
	3. LDRH r1,[r2, #20] => r1 = 0x00001514
LDRHS r1,[r2, #20] [Half Word Signed]
	[2020] 0x14 [2021] 0x15 상위 16비트는 sign bit
	4. LDRHS r1,[r2, #20] => r1 = 0x00001514
STRH r1,[r2, #20] [Half Word]
	[r1] 1000 => 0x000003E8
	5. STRH r1,[r2, #20] => [2020] 0xe8 [2021] 0x03
LDRB r1,[r2, #20] [Byte]
	[2020] 0x14
	6. LDRB r1,[r2, #20] => r1 = 0x00000014
LDRBS r1,[r2, #20]
	[2020] 0x14 상위 24비트는 sign bit
	7. LDRBS r1,[r2, #20] => r1 = 0x00000014
STRB r1,[r2, #20]
	[r1] 1000 => 0x000003E8
	8. STRB r1,[r2, #20] => [2020] 0xe8
SWP r1,[r2, #20]
	r1 과 [2020~2023]번지 메모리가 가진 값을 스왑함
	9. SWP r1,[r2, #20]=> r1 = 0x17161514
			      [2020] 0xe8 [2021] 0x03 [2022] 0x00 [2023] 0x00
MOV r1, r2 [r1 = r2]
	r1에 r2가 가진 값을 저장함.
	10. MOV r1, r2 => r1 = 0x000007d0
```
### 3) 논리 명령어 그룹에 대한 부분이다. 초기 값이 r2=0x76543210, r3=0x98765432, 상태 bit들 N=0, Z=0, C=1, V=0 라고 하자. 첫 두 개의 명령어는 AND, ORR 대신 ANDS, ORRS가 수행된다고 하고 나머지 명령어들은 표에 있는 대로 수행된다고 하자. 수행후 r1 값, 상태비트가 수정되었다면 그 값을 각각 쓰시오. 논리동작 명령어 뒤의 접미사 S에서는 V는 그대로 두고 나머지 N, Z, C 만 update한다.
```
r2 = 0x76 54 32 10 = 0111 0110 0101 0100 0011 0010 0001 0000
r3 = 0x98 76 54 32 = 1001 1000 0111 0110 0101 0100 0011 0010
	N=0, Z=0, C=1, V=0

1. ANDS r1, r2, r3 => 0x10541010 = 0001 0000 0101 0100 0001 0000 0001 0000
2. ORRS r1, r2, r3 => 0xfe767632 = 1111 1110 0111 0110 0111 0110 0011 0010
3. MVN r1, r2 => ~r2 = 0x89abcdef = 1000 1001 1010 1011 1100 1101 1110 1111
4. LSL r1, r2, #10 => r2 << 10 = 0101 0000 1100 1000 0100 0000 0000 0000
			     = 0x50 c8 40 00
5. LSR r1, r2, #10 => r2 >> 10 = 0000 0000 0001 1101 1001 0101 0000 1100
			     = 0x00 1d 95 0c
```
```
Answer)
	ANDS r1, r2, r3 => r1 = 0x10541010 , N=0, Z=0, C=1
	ORRS r1, r2, r3 => r1 = 0xfe767632 , N=1, Z=0, C=1
	MVN r1, r2 => 	    r1 = 0x89abcdef
	LSL r1, r2, #10 => r1 = 0x50c84000 
	LSR r1, r2, #10 => r1 = 0x001d950c
```
### 4) 조건부 분기 명령어 그룹에 대한 부분이다. ①초기 값이 r1=0x76543210, r2=0x98765432, PC=1000 (10진수), 상태 bit들 N=0, Z=0, C=1, V=0 라고 하자. CMP수행후 변경된 상태 비트값을 쓰시오 (CMP는 접미사 S가 없지만 CMPS의 의미로 사용된다). CMP 수행후 PC=1004 (10진수)로 변경되고 변경된 상태 비트가 유지된다. BEQ 25 수행후 PC값을 쓰시오 ② 초기 값이 r1=0x87654321, r2=0x87654321, PC=1000 (10진수), 상태 bit들 N=1, Z=0, C=1, V=0 라고 하자. CMP 수행후 변경된 상태 비트값을 쓰시오. CMP 수행후 PC=1004로 변경되고 변경된 상태 비트가 유지된다. BEQ 25 수행후 PC값을 쓰시오. 
```
PC=1000(10진수), N=0, Z=0, C=1, V=0
r1            = 0x76 54 32 10 = 0111 0110 0101 0100 0011 0010 0001 0000
r2      	      = 0x98 76 54 32 = 1001 1000 0111 0110 0101 0100 0011 0010
-r2(2의 보수) = 0x67 89 AB CE = 0110 0111 1000 1001 1010 1011 1100 1110

	1. CMP r1, r2 => cond.flag = r1 – r2
r1 – r2	     = 0xdd dd dd de = 1101 1101 1101 1101 1101 1101 1101 1110	
	N=1, Z=0, C=0, V=1

	BEQ 25 => if(r1==r2) go to PC + 8 + 25 * 4

		r1 !==r2 (Z !== 1) 이므로 PC = 1008

PC=1000(10진수), N=1, Z=0, C=1, V=0
r1 		= 0x87654321 	= 1000 0111 0110 0101 0100 0011 0010 0001
r2 		= 0x87654321 	= 1000 0111 0110 0101 0100 0011 0010 0001
-r2(2의 보수)   = 0x789abcdf	= 0111 1000 1001 1010 1011 1100 1101 1111 

	2. CMP r1, r2 => cond.flag = r1 – r2

		r1 == r2 이므로 N=0, Z=1, C=1, V=0

	BEQ 25 => if(r1==r2) go to PC + 8 + 25 * 4

		r1 == r2 (Z == 1) 이므로 PC = 1112
```
```
Answer)
	① CMP r1, r2 => N=1, Z=0, C=0, V=1, BEQ 25 => PC = 1008
	② CMP r1, r2 => N=0, Z=1, C=1, V=0, BEQ 25 => PC = 1112
```
### 5) 무조건부 분기 명령어 그룹에 대한 부분이다. ①초기 값이 PC=1000 (10진수), B 200 (10진수) 수행후 PC 값을 쓰시오. ② 초기 값이 PC=1000 (10진수), BL 200 (10진수) 수행후 PC 및 LR 값을 쓰시오.
```
PC=1000(10진수), B 200(10진수)

B 200은 goto PC + 8 + 200 * 4 , PC = 1808

PC=1000(10진수), BL 200(10진수)

BL 명령어 시행 후 r14(또는 LR) 레지스터에 PC + 4 저장 PC = 1808, LR = 1004
```
```
Answer)
	① B 200 => PC = 1808
	② BL 200=> PC = 1808, LR = 1004
```